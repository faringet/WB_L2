## WB_L2

### Как делать задания

- Никаких устных решений — только код.
- Одно решение — один файл с хорошо откомментированным кодом.
- Каждое решение или невозможность решения должны быть объяснены.
- Решения задач должны быть размещены в публичном Git-репозитории и оформлены в соответствии со следующей структурой.
- Разрешается и приветствуется использование любых справочных ресурсов, привлечение сторонних экспертов и т.д. и т.п.
- Основной критерий оценки — четкое понимание «как это работает».

### Задачи

#### [Паттерны проектирования](https://github.com/faringet/WB_L2/tree/master/pattern)

1. Паттерн «фасад».
2. Паттерн «строитель».
3. Паттерн «посетитель».
4. Паттерн «комманда».
5. Паттерн «цепочка вызовов».
6. Паттерн «фабричный метод».
7. Паттерн «стратегия».
8. Паттерн «состояние».

### Задачи на разработку

1. **Базовая задача**
   
   Создать программу, печатающую точное время с использованием NTP-библиотеки. Инициализировать как Go module. Использовать библиотеку `github.com/beevik/ntp`. Написать программу, печатающую текущее время / точное время с использованием этой библиотеки. Требования:
   - Программа должна быть оформлена как Go module.
   - Программа должна корректно обрабатывать ошибки библиотеки: выводить их в STDERR и возвращать ненулевой код выхода в OS.

2. **Задача на распаковку**
   
   Создать Go-функцию, осуществляющую примитивную распаковку строки, содержащую повторяющиеся символы/руны. Например:
   - "a4bc2d5e" => "aaaabccddddde"
   - "abcd" => "abcd"
   - "45" => "" (некорректная строка)
   - "" => ""
   

3. **Утилита `sort`**
   
   Отсортировать строки в файле по аналогии с консольной утилитой `sort`. Реализовать поддержку следующих ключей:
   - `-k` — указание колонки для сортировки (слова в строке могут выступать в качестве колонок, по умолчанию разделитель — пробел).
   - `-n` — сортировать по числовому значению.
   - `-r` — сортировать в обратном порядке.
   - `-u` — не выводить повторяющиеся строки.


4. **Поиск анаграмм по словарю**
   
   Написать функцию поиска всех множеств анаграмм по словарю. Например:
   - 'пятак', 'пятка' и 'тяпка' - принадлежат одному множеству.
   - 'листок', 'слиток' и 'столик' - другому. Требования:
   - Входные данные для функции: ссылка на массив, каждый элемент которого - слово на русском языке в кодировке utf8.
   - Выходные данные: ссылка на мапу множеств анаграмм.
   - Ключ - первое встретившееся в словаре слово из множества. Значение - ссылка на массив, каждый элемент слово из множества.
   - Массив должен быть отсортирован по возрастанию.
   - Множества из одного элемента не должны попасть в результат.
   - Все слова должны быть приведены к нижнему регистру.
   - В результате каждое слово должно встречаться только один раз.

5. **Утилита `grep`**
    
   Реализовать утилиту фильтрации по аналогии с консольной утилитой `grep`. Реализовать поддержку утилитой следующих ключей:
   - `-A` — "after" печатать +N строк после совпадения.
   - `-B` — "before" печатать +N строк до совпадения.
   - `-C` — "context" (A+B) печатать ±N строк вокруг совпадения.
   - `-c` — "count" (количество строк).
   - `-i` — "ignore-case" (игнорировать регистр).
   - `-v` — "invert" (вместо совпадения, исключать).
   - `-F` — "fixed", точное совпадение со строкой, не паттерн.
   - `-n` — "line num", напечатать номер строки.

6. **Утилита `cut`**
    
   Реализовать утилиту аналог консольной команды `cut`. Утилита должна принимать строки через STDIN, разбивать по разделителю (TAB) на колонки и выводить запрошенные.
   Реализовать поддержку утилитой следующих ключей:
   - `-f` — "fields" — выбрать поля (колонки).
   - `-d` — "delimiter" — использовать другой разделитель.
   - `-s` — "separated" — только строки с разделителем.
  
7. **Or channel**
    
   Реализовать функцию, которая будет объединять один или более done-каналов в single-канал, если один из его составляющих каналов закроется. Определение функции:
   ```go
   var or func(channels ...<-chan interface{}) <-chan interface{}
   ```
   Пример использования функции:
     ```go
   sig := func(after time.Duration) <- chan interface{} {
   c := make(chan interface{})
   go func() {
   defer close(c)
   time.Sleep(after) }()
   return c }
   start := time.Now() <-or (
   sig(2*time.Hour), sig(5*time.Minute), sig(1*time.Second), sig(1*time.Hour), sig(1*time.Minute),
   )
   fmt.Printf(“fone after %v”, time.Since(start))
   ```
     
8. **Взаимодействие с ОС**

   Необходимо реализовать свой собственный UNIX-шелл-утилиту с поддержкой ряда простейших команд:
   - cd <args> - смена директории (в качестве аргумента могут быть то-то и то)
   - pwd - показать путь до текущего каталога
   - echo <args> - вывод аргумента в STDOUT
   - kill <args> - "убить" процесс, переданный в качесте аргумента (пример: такой-то пример)
   - ps - выводит общую информацию по запущенным процессам в формате *такой-то формат*
  
9. **Утилита `wget`**

    Реализовать утилиту wget с возможностью скачивать сайты целиком.

10. **Утилита `telnet`**
    
   Реализовать простейший telnet-клиент.

11. **HTTP-сервер**
    
    Реализовать HTTP-сервер для работы с календарем. В рамках задания необходимо работать строго со стандартной HTTP-библиотекой.
    
   
