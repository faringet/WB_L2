package main

/*
	Реализовать паттерн «цепочка вызовов».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern
*/

/*
Поведенческий паттерн проектирования.
Позволяет передавать выполнение запросов последовательно по цепочке. Вызывает обработчик после того, как перед этим вызовет
этот процесс предыдущий обработчик.
Основной кейс - пользователь делает запрос в наш сервис, но при этом бэк начинает проводить авторизацию (сложная бизнес логика).
Сервис - одно звено из всей цепочки. (авторизация - проверка прав юзера итп - это все единая цепочка).

+ уменьшает зависимость между клиентом и обработчиками (каждый обработчик свою роль/логику выполняет независимо)
+ изменять логику обработчиков независимо (общая обработка или нет)
+ реализует принцип единственной обязанности - каждый сервис выполняет свою роль
+ реализует принцип открытости и закрытости

- запрос может остаться необработанным (по какой-то сломанной логике)

В качестве примера будет взаимодействие нескольких сервисов. Будет некое устройство, которое передает данные по некому протоколу.
Первый сервис принимает эти данные и обрабатывает и передает дальше...
... в сервис сохранения данных.
*/

func main() {
	device := &Device{Name: "Device-1"}
	updateSvc := &UpdateDataService{Name: "update-1"}
	dataSvc := &DataService{}

	device.SetNext(updateSvc)  // устройство передает данные сервису обновления
	updateSvc.SetNext(dataSvc) // сервис обновления должен передать данные сервису сохранений
	data := &Data{}            // создаем данные
	device.Execute(data)       // вызов у первого звена обработку данных
}
